<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<style type="text/css">
body { margin:1em;}
pre { background-color:#ddd; padding:10px; margin:20px;}
h1 { font-size=5;color:black}
h2 { font-size=4; color:blue}
h3 { font-size=3; color:gray;}
</style>



<html> <head>
<title></title>
</head>

<body>
<h1>Fun in an art gallery </h1>




<p> In this assignment the goal is to find the visible area of a guard (point)
inside an art gallery (polygon). 

That is, assume you have an input polygon in the plane  that represents the
plan of an art gallery, and a point inside this polygon that
represents a guard. Your task is to implement an algorithm that
computes and displays the part of the gallery visible to the guard.

To manage complexity we'll split it into two parts: 

<ol>

<li>Part 1: the user can click on points, and the code computes and
displays the visible area from that point.


<p><li>Part 2: Extend so that the guard (last point clicked by the
user) is moving inside the polygon, and the visible area is
displayed as the guard is moving. Make it so that the guard does not
get stuck in a corner of the polygon.

</ol>



<h2>The interface</h2>

<ul>
  <li>To make it easy to test, your code will use the mouse to initialize a
polygon, and also to initialize the position of a guard inside the
polygon.

You'll find examples on how to use the mouse in the github repo for
this assignment.

<p><li>The polygon has to be simple. To start, the user should make
sure that the polygon entered is simple.  Ideally there would be a
function that tests whether a polygon is simple.

<p><li>The guard has to be inside the polygon. To start, the user
should make sure it's inside. Ideally there would be a
function that tests whether a point is inside a polygon ---- we'll
talk about this in class, and it's a cool little idea (the degenerate
cases are messy, but there is full pseudocode in the textbook).


<p><li>Once the polygon and the guard are set, run your algorithm that
computes that polygon that's visible and render it with a different
color.


<p>You may have already seen that OpenGL can render a polygon in two
ways: just its boundary (GL_LINE mode), or <i>filled</i> (GL_FILL
mode), by turning on one of:

<pre>
glPolygonMode(GL_LINE);
//glPolygonMode(GL_FILL);
</pre>

<p>Something to be aware of is that openGL can only render filled
polygons that are convex. This seems like a big limitation, however if
you think about it a little it becomes clear that its not trivial to
render a non-convex polygon filled.  Essentially you need to compute
the triangulation of the polygon, and then render one triangle at a
time. Computing a triangulation of a non-convex polygon is a bigger
problem in itself, and OpenGL does not do it as part of glDraw. 

You'll need to find a different way to render the visible non-convex
polygon. Ideally it has to be filled.

</ul>



<h2>Computing the visible polygon</h2>


The crux of this assignment is to come up with an algorithm to compute
the visible polygon of the guard. We have not talked specifically
about this problem in class, so you need to come up with a solution
from scratch.  A quadratic algorithm will be fine.

If you implement an O(n lg n) algorithm you'll get extra credit
and a round of applause in class (hint: radial sweep). If you are
considering an improved algorithm, the papers
listed below may be helpful. 




<p><embed src="vispolygon.pdf" width="600" height="3000" type='application/pdf'>







<h2>Extra features</h2>

Some ideas: 
<ul>
<li>Add more than one guard, both moving, and render the visible area
transparently, so that the overlap is easy to see.
<li>Implement testing whether the point is inside the polygon (ray crossing algorithm)

</ul>



<h3>More reading</h3>

Several algorithm are known for computing the visible polygon faster
than the naive O(n<sup>2</sup>) algorithm: the algorithm by  Joe and
Simpson runs in O(n) time, and the one by Asano in O(n lg n) time. A
recent algorithm by Mungiu et al seems to be teh fastest in practice. 

<ul>
  <li><a
  href="http://cs.smith.edu/~jorourke/books/ArtGalleryTheorems/Art_Gallery_Chapter_8.pdf">Joe
  and Simpson's O(n) visibility polygon</a>
											  
  <li><a href="https://arxiv.org/pdf/1403.3905v1.pdf">Efficient
  computation  of visibility polygons</a> (2014)
  <li><a href="https://doc.cgal.org/latest/Visibility_2/index.html#Chapter_2D_Visibility_Computation">CGAL
  visibility algorithms</a>
  
</ul>

Some cool apps: 
<ul>
<li><a href="http://ncase.me/sight-and-light/">Sight-and-light</a> 

  <li><a href="https://legends2k.github.io/2d-fov/">Field of view and los in 2d</a>
  
  
  <li><a href="http://www.redblobgames.com/articles/visibility/">2d
  visibility</a>

  <li><a
  href="https://davidglavas.me/computing-visibility-polygons/">Glavas
  blog on computing visibility polygons</a>

</ul>





<h3>What to turn in</h3>

<ul>

  <li> Check in your code on GitHub.

  <li>Provide a README that describes
the state of your code (how to run it, does it work on all test cases, do you know of
any bugs, did you implement any extra features, etc). Basically what
  you want people to know about your code. 

  <li>Fill in the <a href="./selfreport-artgallery.pdf">self-reflection report</a> and get it to me (either hard
  copy in class or DM on slack).
 
  </ul>



  



<h2>Some notes on grading</h2>

Functionality: 80 points 
<ul>
  <li>+50 points: find all visible vertices of the polygon  
  <li>+20 points: find the vertices of the visible polygon that fall
  on the edges and interleave them in the right order


  <li>+10 points: moving guard
</ul>

Code Style: 20 points 
<ul>
<li>+0-10 points: poor to medium code.
<li>+10-20 points: medium to excellent code.
</ul>


<h2>Demos from previous classes</h2>

<ul>

   <p> <li>Will and Kevin's <a href="wk-moving_guards.mov" title="Download movie">Moving guards</a>  

    <p><img src="willkevin-guarding.png" border="0" height="200" align="middle">



  <p><li> Dylan and Isaac's <a href="dylanisaac-guarding-demo.mov" title="Download movie">Moving guards</a>   <p><img src="di-guard.png" border="0" height="200" align="middle">


  

  

</ul>

<h2>Program well and enjoy!</h2>



</body> </html>


